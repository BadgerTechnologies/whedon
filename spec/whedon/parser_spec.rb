require "time"
require "date"
require "whedon/parser"

require "spec_helper"

def parse_date(str)
  dt = DateTime.strptime(str, "%Y-%m-%d %H:%M:%S")
  Time.local(dt.year, dt.month, dt.day, dt.hour, dt.min, 0)
end

# describe "Whedon::Parser#parse_element" do
#   [
#     ["*", 0..59, (0..59).to_a],
#     ["*/10", 0..59, [0, 10, 20, 30, 40, 50]],
#     ["10", 0..59, [10]],
#     ["10,30", 0..59, [10, 30]],
#     ["10-15", 0..59, [10, 11, 12, 13, 14, 15]],
#     ["10-40/10", 0..59, [10, 20, 30, 40]],
#   ].each do |element, range, expected|
#     it "should return #{expected} for '#{element}' when range is #{range}" do
#       parser = Whedon::Parser.new('* * * * *')
#       parser.parse_element(element, range).first.to_a.sort.should == expected.sort
#     end
#   end
# end

describe "Whedon::Parser#new" do
  it 'should not raise error when given a valid cronline' do
    expect { Whedon::Parser.new('30 * * * *') }.not_to raise_error
  end

  it 'should raise error when given an invalid cronline' do
    expect { Whedon::Parser.new('* * * *') }.to raise_error("not a valid cronline : '* * * *'")
  end
end

describe "Whedon::Parser#next" do
  [
    ["* * * * *",       "2011-08-15 12:00:00",  "2011-08-15 12:01:00"],
    ["* * * * *",       "2011-08-15 02:25:00",  "2011-08-15 02:26:00"],
    ["* * * * *",       "2011-08-15 02:59:00",  "2011-08-15 03:00:00"],
    ["*/15 * * * *",    "2011-08-15 02:02:00",  "2011-08-15 02:15:00"],
    ["*/15,25 * * * *", "2011-08-15 02:15:00",  "2011-08-15 02:25:00"],
    ["30 3,6,9 * * *",  "2011-08-15 02:15:00",  "2011-08-15 03:30:00"],
    ["30 9 * * *",      "2011-08-15 10:15:00",  "2011-08-16 09:30:00"],
    ["30 9 * * *",      "2011-08-31 10:15:00",  "2011-09-01 09:30:00"],
    ["30 9 * * *",      "2011-09-30 10:15:00",  "2011-10-01 09:30:00"],
    ["0 9 * * *",       "2011-12-31 10:15:00",  "2012-01-01 09:00:00"],
    ["* * 12 * *",      "2010-04-15 10:15:00",  "2010-05-12 00:00:00"],
    ["* * * * 1,3",     "2010-04-15 10:15:00",  "2010-04-19 00:00:00"],
    ["* * * * MON,WED", "2010-04-15 10:15:00",  "2010-04-19 00:00:00"],
    ["0 0 1 1 *",       "2010-04-15 10:15:00",  "2011-01-01 00:00:00"],
    ["0 0 * * 1",       "2011-08-01 00:00:00",  "2011-08-08 00:00:00"],
    ["0 0 * * 1",       "2011-07-25 00:00:00",  "2011-08-01 00:00:00"],
    ["45 23 7 3 *",     "2011-01-01 00:00:00",  "2011-03-07 23:45:00"],
#    ["0 0 1 jun *",     "2013-05-14 11:20:00",  "2013-06-01 00:00:00"],
#    ["0 0 1 may,jul *", "2013-05-14 15:00:00",  "2013-07-01 00:00:00"],
#    ["0 0 1 MAY,JUL *", "2013-05-14 15:00:00",  "2013-07-01 00:00:00"],
  ].each do |line, now, expected_next|
    it "should return #{expected_next} for '#{line}' when now is #{now}" do
      now = parse_date(now)
      expected_next = parse_date(expected_next)

      parser = Whedon::Parser.new(line)

      parser.next(now).xmlschema.should == expected_next.xmlschema
    end
  end
end

describe "Whedon::Parser#last" do
  [
    ["* * * * *",       "2011-08-15 11:59:59",  "2011-08-15 11:59:00"],
    ["* * * * *",       "2011-08-15 02:24:59",  "2011-08-15 02:24:00"],
    ["* * * * *",       "2011-08-15 02:59:59",  "2011-08-15 02:59:00"],
    ["*/15 * * * *",    "2011-08-15 02:02:00",  "2011-08-15 02:00:00"],
    ["*/15,45 * * * *", "2011-08-15 02:55:00",  "2011-08-15 02:45:00"],
    ["*/15,25 * * * *", "2011-08-15 02:35:00",  "2011-08-15 02:30:00"],
    ["30 3,6,9 * * *",  "2011-08-15 02:15:00",  "2011-08-14 09:30:00"],
    ["30 9 * * *",      "2011-08-15 10:15:00",  "2011-08-15 09:30:00"],
    ["30 9 * * *",      "2011-09-01 08:15:00",  "2011-08-31 09:30:00"],
    ["30 9 * * *",      "2011-10-01 08:15:00",  "2011-09-30 09:30:00"],
    ["0 9 * * *",       "2012-01-01 00:15:00",  "2011-12-31 09:00:00"],
    ["* * 12 * *",      "2010-04-15 10:15:00",  "2010-04-12 23:59:00"],
    ["* * * * 1,3",     "2010-04-15 10:15:00",  "2010-04-14 23:59:00"],
    ["* * * * MON,WED", "2010-04-15 10:15:00",  "2010-04-14 23:59:00"],
    ["0 0 1 1 *",       "2010-04-15 10:15:00",  "2010-01-01 00:00:00"],
#    ["0 0 1 jun *",     "2013-05-14 11:20:00",  "2012-06-01 00:00:00"],
#    ["0 0 1 may,jul *", "2013-05-14 15:00:00",  "2013-05-01 00:00:00"],
#    ["0 0 1 MAY,JUL *", "2013-05-14 15:00:00",  "2013-05-01 00:00:00"],
  ].each do |line, now, expected_next|
    it "should return #{expected_next} for '#{line}' when now is #{now}" do
      now = parse_date(now)
      expected_next = parse_date(expected_next)

      parser = Whedon::Parser.new(line)

      parser.last(now).should == expected_next
    end
  end
end
